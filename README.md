# Отчет по проекту: Интерпретатор функционального языка программирования на F#

## Цель проекта
Целью данного проекта является изучение и реализация собственного функционального языка программирования. Для достижения этой цели были поставлены следующие задачи:

- Реализовать техно скелет парсинга функционального программирования, включая базовую логику разбора выражений и численных операций, а также логику комбинаторной логики.
- Обеспечить возможность обработки универсальных конструкций, таких как рекурсия, и поддержку творчества в идеале — полный по Тьюрингу функционал.
- Минимизировать язык, но при этом сохранить достаточную функциональность для расчета факториала.

Проект направлен на создание интерпретатора, который способен обрабатывать выражения функционального языка, включая базовые операции, условные конструкции, лямбда-выражения, рекурсию и многое другое.

---

## Реализованные функции

#### Модуль `Ast.fs` определяет абстрактное синтаксическое дерево (AST), которое используется для представления выражений языка. Определены следующие конструкции:

- **Базовые типы:** `Number` (целые числа), `Bool` (булевы значения), `String` (строки),  `Symbol` (символы/переменные).
- **Условные конструкции:** `If` (условие, ветка "тогда", ветка "иначе").
- **Привязка переменных:** 
    - `Let` (привязка одной переменной).
    - `LetRec` (рекурсивная привязка).
    - `LetMany` (множественные привязки).
    - `LetStar` (последовательные привязки с телом).
- **Функциональные конструкции:** 
    - `Lambda` (создание лямбда-выражений с параметрами и телом).
    - `Call` (вызов функции с аргументами).
- **Операции:** 
    - `BinaryOp` (бинарные операции, такие как +, -, *, /, =, <, >, and, or).
    - `UnaryOp` (унарные операции, такие как not).
- **Списки и работа с ними:** `ListExpr` (списки выражений).
- **Паттерн-матчинг:** `Match` (конструкция для сопоставления с образцом, частично реализована).
- **Цитирование:** `Quote` (цитирование выражений).
- **Определения:** `Define` (определение переменных и функций).
- **Последовательность:** `Begin` (последовательное выполнение выражений).


#### Модуль `Value.fs` определяет значения, которые используются в runtime интерпретатора, а также окружение (`Env`):

- **Типы значений:**
    - `VNumber` (целые числа).
    - `VBool` (булевы значения).
    - `VString` (строки).
    - `VSymbol` (символы, не используется активно).
    - `VList` (списки значений).
    - `VClosure` (замыкания с параметрами, телом и ссылкой на окружение).
    - `VBuiltin` (встроенные функции с именем и реализацией).


- **Окружение:** `Env` — это `Map<string, Value>`, хранящий привязки имен к значениям.
- **Исключения:** Определено исключение `RuntimeError` для обработки ошибок во время выполнения.
- **Печать:** Модуль `Printer` предоставляет функцию `printValue` для преобразования значений в читаемый вид (например, списки отображаются в скобках, булевы значения как `#t/#f`).

#### Модуль `Parser.fs` отвечает за парсинг исходного кода в AST. Основные функции:

- **Токенизация** (`tokenize`): Разбивает входную строку на токены, добавляя пробелы вокруг скобок и удаляя лишние пробелы.
- **Парсинг выражений** (`parseExpr`, `parseList`, `parseMany`):
    - Поддерживает базовые атомы: числа, булевы значения (`true/false`), строки (в кавычках), символы.
- **Обрабатывает списки** (`ListExpr`) **и конструкции, такие как:**
    - `if` (условие, тогда, иначе).
    - `let` (привязка переменной).
    - `lambda` (создание лямбда-выражений).
    - `list` (создание списков).
    - `quote` (цитирование выражений).
    - `define` определение переменных и функций, включая синтаксис `(define (name  args...) body))`.
    - `begin` (последовательное выполнение).
    - `match` (сопоставление с образцом, частично реализован).
    - Бинарные и унарные операции (например, `(+ 1 2), (not #t)`).
    - Вызовы функций (например, `(f x y)`).

- **Вспомогательные функции:**
    - `parseArgs` (парсинг аргументов для `lambda` и `define`).
    - `parseMatchCases` (парсинг случаев для `match`).
    - `isBinaryOp` и `isUnaryOp` (проверка операторов).

#### Модуль `Interpreter.fs` реализует интерпретатор, который вычисляет выражения из AST. Основные компоненты:

- **Встроенные функции** (`builtins`): Определены примитивы:
    - Арифметические: `+`, `-`, `*`, `/`.
    - Сравнение: `=`, `<`, `>`.
    - Логические: `not`, `and`, `or`.
    - Работа со списками: `list`, `empty`, `head`, `sum`, `cons`, `tail`.

- **Базовое окружение** (`baseEnv`): Создается на основе встроенных функций.
- **Оценка выражений** (`eval`):
    - Поддерживает базовые типы (`Number`, `Bool`, `String`, `ListExpr`).
    - Обрабатывает символы, проверяя их в окружении.
    - Реализует унарные и бинарные операции через вызовы встроенных функций.
    - Обрабатывает условные конструкции (`If`).
    - Создает замыкания (`Lambda`) с текущим окружением.
    - Выполняет вызовы функций (`Call`) через `apply`.
    - Реализует привязку переменных (`Let`, `Define`).
    - Поддерживает последовательное выполнение (`Begin`).
    - Обрабатывает цитирование (`Quote`).

- **Применение функций** (`apply`):
    - Для встроенных функций (`VBuiltin`) вызывает их реализацию.
    - Для замыканий (`VClosure`) создает новое окружение с аргументами и вычисляет тело.

- Обработка `begin` (`evalBegin`): Выполняет выражения последовательно, обновляя окружение при использовании `Define`.

---

## Основная работа

### Этап 1: Разработка синтаксического дерева и парсера для языка
На этом этапе было создано абстрактное синтаксическое дерево (`Ast.fs`) для представления всех конструкций языка. Парсер (`Parser.fs`) был разработан для преобразования текстового кода в AST. 
**Пример:**
```
(+ 1 2)
```

Парсер преобразует это в `BinaryOp("+", Number 1, Number 2)`.

### Этап 2: Разработка интерпретатора/компилятора для языка
Был реализован интерпретатор (`Interpreter.fs`), который вычисляет выражения из AST. Он поддерживает базовые операции, условные конструкции, лямбда-выражения и работу со списками. 
**Пример:**
```
(begin
  (define (fact n)
    (if (= n 0)
        1
        (* n (fact (- n 1)))))
  (fact 5))
```

Интерпретатор корректно вычисляет факториал, возвращая `120`.

### Этап 3: Написание примеров программ и документации
Ниже приведены примеры программ, демонстрирующие возможности языка.

**[Пример 1: Базовые арифметические операции ](examples/arithmetic.fsx)**
```
(begin
  (define calc
    (lambda ()
      (list
        (+ 5 3)
        (- 10 2)
        (* 3 4)
        (/ 20 5))))
  (calc))
```

Результат: `4`.

**[Пример 2: Замыкания и let](examples/closures.fsx)**
```
(begin
  (define make-adder (lambda (x) (lambda (y) (+ x y))))
  
  (begin
    (define add5 (make-adder 5))
    (add5 3)))
```

Результат: `8`.

**[Пример 3: Условные выражения](examples/conditions.fsx)**
```
(begin
  (if (> 10 5) 
      "Верно" 
      "Неверно"))
```

Результат: `Верно`.

**[Пример 4: Факториал через `define`](examples/factorial.fsx)**
```
(begin
  (define (fact n)
    (if (= n 0)
        1
        (* n (fact (- n 1)))))
  (fact 5))
```

Результат: `120`.

**[Пример 5: Фибоначчи](examples/fibonacci.fsx)**
```
(begin
  (define fib-impl
    (lambda (self n)
      (if (< n 2)
          n
          (+ (self self (- n 1)) (self self (- n 2))))))

  (define fib 
    (lambda (n) 
      (fib-impl fib-impl n)))

  (fib 10))
```

Результат: `55`.

**[Пример 6: Лямбда-функции](examples/lambda.fsx)**
```
(begin
  (define square (lambda (x) (* x x)))
  (square 5))
```

Результат: `25`.

**[Пример 7: Работа со списками](examples/lists.fsx)**
```
(begin
  (define my-list (list 1 2 3 4))
  (list (head my-list) 
        (tail my-list)))
```

Результат: `(1 (2 3 4))`.

**[Пример 8: Логические операции](examples/logical.fsx)**
```
(begin
  (define logical-test
    (lambda ()
      (list
        (and true false)
        (or true false)
        (not false))))
  (logical-test))
```

Результат: `#f #t #t`.

**[Пример 9: Использование `map`](examples/map.fsx)**
```
(begin
  (define double (lambda (x) (* 2 x)))
  (define map3
    (lambda (f lst)
      (list 
        (f (head lst))
        (f (head (tail lst)))
        (f (head (tail (tail lst)))))))
  
  (map3 double (list 1 2 3)))
```

Результат: `2 4 6`.

**[Пример 10: Сумма элементов списка](examples/sumList.fsx)**
```
(sum (list 1 2 3 4 5))
```

Результат: `15`.

## Заключение
Проект успешно реализует базовый интерпретатор функционального языка, который поддерживает основные конструкции, такие как лямбда-выражения, условные операторы, работа со списками и рекурсия. Язык является достаточно мощным, чтобы вычислять факториал, что соответствует поставленной цели. Отдельно стоит отметить, что парсер (`Parser.fs`), в частности функции `parseExpr` и `parseList`, был разработан с использованием `Deepseek`, что позволило ускорить процесс реализации и обеспечить точность синтаксического анализа, а также часть интерпретатора (`Interpreter.fs`), а именно обработка базовых типов и условных конструкций в функции `eval`, были разработаны с использованием `ChatGPT`. В будущем можно расширить функциональность, добавив новые возможности и улучшив производительность.


## Команда разработчиков

| ФИО                        | Роль в проекте                     |
| ---------------------------|------------------------------------|
| Махмутов Дэниз Ирикович    | Архитектор/Разработчик парсера     |
| Слободин Никита Алексеевич | Инженер интерпретатора/Компоновщик |
| Степанов Никита Евгеньевич | Тестировщик/Документатор           |
